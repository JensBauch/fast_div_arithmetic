freeze;

AddAttribute(RngInt,"Error");
//Attach("~/Doctorado/Magma/Montes/GlobalFF.m");
//SetIgnoreEof(true);
//SetIgnoreSpaces(true);

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////Helpfunction for function fields /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


intrinsic 'mod'(alpha:: FldFunElt, p:: RngUPolElt)->FldFinElt
{Realizes the reduction map ZK--> ZK/pZK}

	R:=Parent(p);
	num:=Numerator(alpha);
	den:=Denominator(alpha);
	return (Parent(alpha)![R!i mod p:i in Eltseq(num)])/den;

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Random(A::RngUPol, l::RngIntElt)->RngUPolElt
{}
Fq := CoefficientRing(A);
require IsFinite(Fq): "A must be a polynomial ring over a finite field";
L :=[];
for i in [1..l+1] do
	Append(~L,Random(Fq));
end for;	
return A!L;

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic RandomQ(A::RngUPol, l::RngIntElt)->RngUPolElt
{}

L :=[];
for i in [1..l] do
	Append(~L,Random(Integers(),5));
end for;	
return A!L;

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Numerator(z:: FldFunElt)->FldFunElt
{Determines the Nominator of a FldFunElt z}

	return Parent(z)!Numerator(z,EquationOrderFinite(Parent(z)));

end intrinsic;




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


intrinsic DefiningMonicPolynomial(F::FldFun)->FldFun
{}
if IsMonic(DefiningPolynomial(F)) then

	F`MonicDefiningPoly:=DefiningPolynomial(F);

end if;

if not assigned F`MonicDefiningPoly then
	 F`MonicDefiningPoly:=DefiningPolynomial(Normalization(F));
end if;

return F`MonicDefiningPoly;
end intrinsic;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



intrinsic Denominator(z:: FldFunElt)->FldFunElt
{Determines the denominator of z}

	return Parent(z)!Denominator(z,EquationOrderFinite(Parent(z)));

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic IntegerToBinary(n::RngIntElt)->SeqEnum
{Compute binary representation of an integer n}
	L:=[];
	if n lt 0 then 
		n:=Abs(n);
		help:=-1;
	else;
		help:=1;
	end if;

	while n gt 0 do
		Append(~L,help*Integers()!(n mod 2));
		n:=n div 2;
	end while;

	return L;

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic IntegerTopAdic(n::RngIntElt,p::RngIntElt)->SeqEnum
{Compute binary representation of an integer n}
	L:=[];
	if n lt 0 then 
		n:=Abs(n);
		help:=-1;
	else;
		help:=1;
	end if;

	while n gt 0 do
		Append(~L,help*Integers()!(n mod p));
		n:=n div p;
	end while;

	return L;

end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



intrinsic Evaluate(F::FldFun,z::RngUPolElt)->FldFunElt
{Evaluates Polynomial in F.1}

	L:=Eltseq(z);
	if #L gt Degree(F) then
		print"Error in Eval";
		return z;
	end if;

	return F!(L cat [0:i in [1..Degree(F)-#L]]);
end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Deg(z::FldFunElt)->RngIntElt
{}
//if z eq 0 then return -Infinity();end if; // ist vielleicht noch mal hilfreich
F := Parent(z);	A<t> := PolynomialRing(ConstantField(F)); Ax := PolynomialRing(A);


return Degree(Ax!Eltseq(Numerator(z)));

end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


intrinsic Deg(f::FldFunRatUElt)->RngIntElt
{Let f=g/h with (g,h)=1. Then Degree(f)=Degree(g)-Degree(h)}

return Degree(Numerator(f))-Degree(Denominator(f));

end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic DegNorm(f::FldFunRatUElt)->RngIntElt
{Let f=g/h with (g,h)=1. Then Degree(f)=Degree(g)-Degree(h)}

if f eq 0 then return -Infinity(); end if;

return Degree(Numerator(f))-Degree(Denominator(f));

end intrinsic;




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


intrinsic Norm(Vec::SeqEnum, Values::SeqEnum)->FldRatElt
{}
tmp:=[i : i in [1..#Values]|not Vec[i] eq 0];
return Maximum([Degree(Vec[i])+Values[i]:i in tmp]);

end intrinsic;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////End of  Helpfunction for function fields /////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////Helpfunction for Lists////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

//Remark: Since the idealfactors are represented by [p(x),1,2] we have to deal with lists!
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Sort(L::SeqEnum,SortL::SeqEnum)->SeqEnum
{Gives Bijection between L and SortL}

	Per:=[];
	for i in [1..#L] do
		j:=Position(L,SortL[i]);
		Append(~Per,j);
		L[j]:=-2;
	end for;

	return Per;

end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Sort(L::List)->List
{Sorts a list}

	Level1:=[**];
	L1:=[i[1]: i in L];
	Sort1:=Sort(L1);
	for i in Sort1 do
		Append(~Level1,L[Position(L1,i)]);
		L1[Position(L1,i)]:=0;
	end for;
	Level2:=[**];
	j:=1;
	for p in SetToSequence(Set(Sort1)) do
		TempP:=[];
		while p eq  Sort1[j] do
			Append(~TempP,Level1[j]);	
			if j eq #Sort1 then break; end if;
			j:=j+1;
		end while;
		L2:=[i[2]: i in TempP];
		Sort2:=Sort(L2);
	
		for i in Sort2 do
			Append(~Level2,TempP[Position(L2,i)]);
			L2[Position(L2,i)]:=0;
		end for;
	end for;

	return Level2;
end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic Sort2(L::List)->List
{Helpmethod for Sort}

	Step1:=Sort(SetToSequence(Set([i[1]:i in L])));
	HelpList:=[*[* *]:i in [1..#Step1]*];
	for j in [1..#Step1] do
		for i in L do
			if i[1] eq Step1[j] then
				Append(~HelpList[j],i);
			end if;
		end for;
		Step2:=Sort(SetToSequence(Set([ii[2]:ii in HelpList[j]])));
		HelpList2:=[**];
		for kk in [1..#Step2] do

		for mm in HelpList[j]   do
			if mm[2] eq Step2[kk] then 
				Append(~HelpList2,mm);
			end if;
		end for;
	
		end for;
	HelpList[j]:=HelpList2;
	end for;
	temp:=[* *];
	for i in HelpList do
		temp:=temp cat i;
	end for;
	return temp;
end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic 'in'(L1::List,L2::List)->BoolElt
{Some special helpfunction}

	if #L2 eq 0 or #L1 eq 0 then return false,0; end if;
	for i in [1..#L2] do
		if L1[1] eq L2[i][1] and L1[2] eq L2[i][2] then return true,i; end if;  
	end for;

	return false,0;

end intrinsic;



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//Only for my Version!!!! The new magma version does not need it!

intrinsic 'eq'(L1::List ,L2:: List)-> BoolElt
{}
if not #L1 eq #L2 then return false;end if;
for i in [1..#L1] do
	for j in [1..3] do
		if not L1[i,j] eq L2[i,j] then return false; end if;
	end for;
end for;
return true;
end intrinsic;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


intrinsic 'in'(P::Rec ,L:: SeqEnum)-> BoolElt
{}
if  #L eq 0 then return false,0;end if;
for i in [1..#L] do

		if P eq L[i] then return true,i; end if;
end for;
return false,0;
end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////End of helpfunctions for Lists/////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

intrinsic Normalization(F::FldFun)->FldFun
{Bekommt Funktionenkörper mit definieirenden Polynom f und gibt definierendes Polnynom 
f' aus, wobei f' normiert ist und Koeffizienten in k[t] hat}

f:=DefiningPolynomial(F);
CoeffList:=Eltseq(f);
NewCoeff:=[Parent(CoeffList[1])!1];
alpha:=LCM([Denominator(i):i in CoeffList]);
Nennerfrei:=Reverse([alpha*i :i in CoeffList]);
an:=Nennerfrei[1];
for i in [2..#Nennerfrei] do

	Append(~NewCoeff,an^(i-2)*Nennerfrei[i]);

end for;

return FunctionField(Parent(f)!Reverse(NewCoeff));

end intrinsic;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

intrinsic DefiningMonicPolynomial(F::FldFun)->FldFun
{}

if IsMonic(DefiningPolynomial(F)) then

	F`MonicDefiningPoly:=DefiningPolynomial(F);

end if;

if not assigned F`MonicDefiningPoly then
	 F`MonicDefiningPoly:=DefiningPolynomial(Normalization(F));
end if;

return F`MonicDefiningPoly;
end intrinsic;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


intrinsic Eltseq(a::FldRatElt,Q::FldRat) -> SeqEnum
{}

return [a];
end intrinsic;



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


intrinsic deg(a::FldFunRatUElt) -> RngIntElt
{}

if a eq 0 then return -1*Valuation(0,2); end if;
K := Parent(a); A := PolynomialRing(BaseRing(K));

return Degree(A!Numerator(a))-Degree(A!Denominator(a));
end intrinsic;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

intrinsic InitialeModRing(R::RngUPol,q::RngUPolElt)->RngUPol
{}
A:=CoefficientRing(R);
quot<tt>:=quo<A|q>;
R<xx>:=PolynomialRing(quot);
return R;
end intrinsic;
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


intrinsic PutModRing(RMod::RngUPol,g::RngUPolElt)->RngUPol
{}

k:=BaseRing(CoefficientRing(Parent(g)));
A:=PolynomialRing(k);
Amod:=CoefficientRing(RMod);
return RMod![Amod!(A!i):i in  Eltseq(g)];


end intrinsic;


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

intrinsic ChangePrecMod(g::RngUPolElt,q::RngUPolElt)->RngUPol
{}
R:=Parent(g);	R:=BaseRing(BaseRing(R));
A:=PolynomialRing(PolynomialRing(R));
RMod:=InitialeModRing(A,q);
return PutModRing(RMod,A!g);


end intrinsic;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

intrinsic PutInZ(A) -> RngIntElt
 {}
Z := Integers();
if assigned Z`Error then
  Append(~Z`Error, A);
else
  Z`Error := [*A*];
end if;

return #Z`Error;
end intrinsic;





//############################


intrinsic Random_FunctionField_with_index(deg::RngIntElt,q::RngIntElt,B::RngIntElt)->FldFun
{produces more or less random function field of degree deg over finite field with 
	q elements - coefficients of f are bounded by B}


F := Random_FunctionField(deg,q,B);

while Index(F) eq 0 do
F := Random_FunctionField(deg,q,B);

end while;
	
return F;

	
end intrinsic;


//############################


intrinsic Random_FunctionField(deg::RngIntElt,q::RngIntElt,B::RngIntElt)->FldFun
{produces more or less random function field of degree deg over finite field with 
	q elements - coefficients of f are bounded by B}

Fp := FiniteField(q);
Fpt<t> := PolynomialRing(Fp);
Fpx<x> := PolynomialRing(Fpt);


f := x^deg + Fpx![Random(Fpt,Random([0..B])): i in [1..deg]];

while not IsIrreducible(f) do
	f := x^deg + Fpx![Random(Fpt,Random([0..B])): i in [1..deg]];
end while;
	
return FunctionField(f);

	
end intrinsic;


